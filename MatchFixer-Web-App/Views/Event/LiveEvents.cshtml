@using MatchFixer.Core.ViewModels.LiveEvents
@model IEnumerable<LiveEventViewModel>

@{
    ViewData["Title"] = "Match Events Board";
}

<div class="tw-h-100" style="overflow-y: visible; overflow-x: visible;">
<div class="border-0 rounded-4 p-4 flex-fill">
	@if (TempData["SuccessMessage"] != null)
	{
		<div class="alert success-message" id="success-message">
			@TempData["SuccessMessage"]
		</div>
	}

	@if (TempData["ErrorMessage"] != null)
	{
		<div class="alert error-message" id="error-message">
			@TempData["ErrorMessage"]
		</div>
	}

</div>


	
@await Html.PartialAsync("_WikipediaTooltipPartial")

	<div class="container mt-4">

		<div class="game-background">
		</div>

		@if (!Model.Any())
		{
			<div class="alert alert-info text-center">
				No match events available at the moment.
			</div>
		}
		else
		{
			<div id="noMatchesMessage" class="no-matches-message text-center">
				No matching teams found.
			</div>

			<div class="d-flex flex-column align-items-center gap-3 mb-4 position-relative">

				<div class="w-100 d-flex justify-content-center">
					<div class="input-group" style="max-width: 400px;">
						<span class="input-group-text bg-white border-end-0">
							<i class="bi bi-search animate__animated animate__flipInX"></i>
						</span>
						<input type="text" id="matchSearch" class="form-control border-start-0" placeholder="Search team name..." oninput="filterMatches()" />
					</div>
					<div id="matchCount"
					     class="text-muted fw-semibold text-center" style="font-size: 0.75em; margin-left: 1em; display: flex; justify-content: center; align-items: center;">
						Available matches: 0
					</div>
				</div>
			

				<div id="datePillContainer" class="d-flex flex-wrap justify-content-center gap-2 position-relative" style="z-index: 1;">
				</div>

			</div>

			<div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 g-4 d-flex align-items-stretch">
				@foreach (var match in Model)
				{
					<div class="col">
						<div class="event-card position-relative"
						     data-match-id="@match.Id"
						     data-kickoff="@(match.KickoffTime?.ToString("o") ?? "")"
						     data-user-tz="@match.UserTimeZone"
						     data-has-boost="@(match.ActiveBoost != null ? "true" : "false")"
						     data-postponed="@(match.IsPostponed ? "true" : "false")">


								<div class="live-event-card tw-card tw-shadow-sm tw-h-100 gap-2">
									<div class="card-body d-flex flex-column justify-content-around 
										@(match.ActiveBoost != null
										 ? "boosted-match-container-effects" 
										 : (match.IsDerby ? "derby-match-container-effects" : ""))" style="position: relative; object-fit: contain;">
									

									<div id="oneVsOneContainer">
										@if (match.IsDerby)
										{
											<span class="derby-match-tooltip-wrapper">
												<img class="animate__animated animate__heartBeat animate__slower animate__infinite" id="derby-match-icon" src="/images/live-events/derby-match.png" alt="derby match" style="width: auto; height: 40px;" class="img-fluid mb-2"/>
												<span class="derby-match-tooltip">Derby Match
												</span>
											</span>
										}
									</div>
									<div class="d-flex justify-content-around align-items-center mb-2 mt-2 @(match.IsDerby ? "derby-negative-margin" : "")">

										<div class="tw-flex tw-justify-around tw-items-center mb-2 gap-4">
											<div class="text-center">
												<div class="tw-flex  tw-flex-col  tw-items-center  tw-justify-center">
													<img src="@match.HomeTeamLogoUrl" alt="@match.HomeTeam" style="width: auto; height: 60px;" class="mb-2 team-logo hoverable-logo" data-team-name="@match.HomeTeam" />
													<div class="event-team-name">@match.HomeTeam</div>
												</div>
											</div>


											<img src="/images/live-events/versus.png" alt="@match.HomeTeam" style="width: auto; height: 40px;" class="img-fluid mb-2"/>

											<div class="text-center">
												<div class="flex flex-col items-center justify-center object-fit-contain">
													<img src="@match.AwayTeamLogoUrl" alt="@match.AwayTeam" style="width: auto; height: 60px;" class="mb-2 team-logo hoverable-logo" data-team-name="@match.AwayTeam" />
													<div class="event-team-name">@match.AwayTeam</div>
												</div>
											</div>
										</div>
									</div>
									<p id="event-date-time" class="tw-card-text text-brand-oxford-blue text-center text-muted mb-2 animate__animated animate__heartBeat">
										@* @match.KickoffTime.ToString("f") *@
									</p>

									<div class="d-flex justify-content-around mb-3">

										<div class="tw-overflow-x-auto">
											
											<table class="odds-table tw-min-w-full tw-bg-white tw-rounded-lg tw-overflow-hidden">
												<thead class="tw-bg-gray-50 tw-shadow">
												<tr>
														<th id="home-header" class="tw-px-4 tw-py-3 tw-text-center tw-text-xs tw-font-medium tw-text-gray-600 bet-trigger animate__animated animate__slideInDown" data-column-index="0"
													    data-match-id="@match.Id"
													    data-home="@match.HomeTeam"
													    data-away="@match.AwayTeam"
													    data-home-logo-url="@match.HomeTeamLogoUrl"
													    data-away-logo-url="@match.AwayTeamLogoUrl"
													    data-option="Home"
													    data-odds="@match.HomeWinOdds"
													    data-start-time="@(match.KickoffTime?.ToString("o") ?? "")">

														<button class="bet-option @(match.ActiveBoost != null ? "boosted" : "")">
															Home
														</button>
													</th>
														<th id="draw-header" class="tw-px-4 tw-py-3 tw-text-center tw-text-xs tw-font-medium tw-text-gray-600 bet-trigger animate__animated animate__slideInDown" data-column-index="1"
													    data-match-id="@match.Id"
													    data-home="@match.HomeTeam"
													    data-away="@match.AwayTeam"
													    data-home-logo-url="@match.HomeTeamLogoUrl"
													    data-away-logo-url="@match.AwayTeamLogoUrl"
													    data-option="Draw"
													    data-odds="@match.DrawOdds"
													    data-start-time="@(match.KickoffTime?.ToString("o") ?? "")">

														<button class="bet-option @(match.ActiveBoost != null ? "boosted" : "")">
															Draw
														</button>
													</th>
														<th id="away-header" class="tw-px-4 tw-py-3 tw-text-center tw-text-xs tw-font-medium tw-text-gray-600 bet-trigger animate__animated animate__slideInDown" data-column-index="2"
													    data-match-id="@match.Id"
													    data-home="@match.HomeTeam"
													    data-away="@match.AwayTeam"
													    data-home-logo-url="@match.HomeTeamLogoUrl"
													    data-away-logo-url="@match.AwayTeamLogoUrl"
													    data-option="Away"
													    data-odds="@match.AwayWinOdds"
													    data-start-time="@(match.KickoffTime?.ToString("o") ?? "")">

														<button class="bet-option @(match.ActiveBoost != null ? "boosted" : "")">
															Away
														</button>
													</th>
												</tr>
												</thead>
												<tbody class="tw-divide-y tw-divide-gray-200">
												<tr>
													<!-- Home Odds -->
													<td class="tw-px-4 tw-py-4 tw-whitespace-nowrap tw-text-center bet-trigger">
															<span class="badge tw-inline-flex tw-items-center tw-px-3 tw-py-1.5 tw-rounded-full tw-text-xs tw-font-semibold animate__animated animate__slideInUp
														@(match.ActiveBoost != null ? "pill-boosted-blue" : "pill-brand-blue")"
														      data-match-id="@match.Id"
														      data-home="@match.HomeTeam"
														      data-away="@match.AwayTeam"
														      data-home-logo-url="@match.HomeTeamLogoUrl"
														      data-away-logo-url="@match.AwayTeamLogoUrl"
														      data-option="Home"
														      data-has-boost="@(match.ActiveBoost != null ? "true" : "false")"
														      data-odds="@(match.EffectiveHomeWinOdds ?? match.HomeWinOdds)">
															@if (match.ActiveBoost != null)
															{
																<div class="d-flex flex-column align-items-center justify-content-center">
																	<span class="old-odds">@match.HomeWinOdds</span>
																	<span class="boosted-odds">@match.EffectiveHomeWinOdds</span>
																</div>
															}
															else
															{
																@match.HomeWinOdds
															}
														</span>
													</td>

													<!-- Draw Odds -->
													<td class="tw-px-4 tw-py-4 tw-whitespace-nowrap tw-text-center bet-trigger">
															<span class="badge tw-inline-flex tw-items-center tw-px-3 tw-py-1.5 tw-rounded-full tw-text-xs tw-font-semibold animate__animated animate__slideInUp
																		@(match.ActiveBoost != null ? "pill-boosted-yellow" : "pill-brand-yellow")"

														      data-match-id="@match.Id"
														      data-home="@match.HomeTeam"
														      data-away="@match.AwayTeam"
														      data-home-logo-url="@match.HomeTeamLogoUrl"
														      data-away-logo-url="@match.AwayTeamLogoUrl"
														      data-option="Draw"
														      data-has-boost="@(match.ActiveBoost != null ? "true" : "false")"
														      data-odds="@(match.EffectiveDrawOdds ?? match.DrawOdds)">
															@if (match.ActiveBoost != null)
															{
																<div class="d-flex flex-column align-items-center justify-content-center">
																	<span class="old-odds">@match.DrawOdds</span>
																	<span class="boosted-odds">@match.EffectiveDrawOdds</span>
																</div>
															}
															else
															{
																@match.DrawOdds
															}
														</span>
													</td>

													<!-- Away Odds -->
													<td class="tw-px-4 tw-py-4 tw-whitespace-nowrap tw-text-center bet-trigger">
															<span class="badge tw-inline-flex tw-items-center tw-px-3 tw-py-1.5 tw-rounded-full tw-text-xs tw-font-semibold animate__animated animate__slideInUp
															@(match.ActiveBoost != null ? "pill-boosted-green" : "pill-brand-green")"
														      data-match-id="@match.Id"
														      data-home="@match.HomeTeam"
														      data-away="@match.AwayTeam"
														      data-home-logo-url="@match.HomeTeamLogoUrl"
														      data-away-logo-url="@match.AwayTeamLogoUrl"
														      data-option="Away"
														      data-has-boost="@(match.ActiveBoost != null ? "true" : "false")"
														      data-odds="@(match.EffectiveAwayWinOdds ?? match.AwayWinOdds)">
															@if (match.ActiveBoost != null)
															{
																<div class="d-flex flex-column align-items-center justify-content-center">
																	<span class="old-odds">@match.AwayWinOdds</span>
																	<span class="boosted-odds">@match.EffectiveAwayWinOdds</span>
																</div>
															}
															else
															{
																@match.AwayWinOdds
															}
														</span>
													</td>

												</tr>
												@if (match.ActiveBoost != null)
												{
													<tr class="boost-timer-row" data-boost-end="@match.ActiveBoost?.EndUtc.ToString("o")">
														<td colspan="3" class="text-center">

															<span class="badge pill-boosted tw-inline-flex tw-items-center tw-px-3 tw-py-1.5 tw-rounded-full tw-text-xs tw-font-semibold">
																<i class="ri-fire-fill boost-fire-icon me-1"></i>
																<span class="boost-countdown"> 00:00</span>
															</span>
															<small class="badge text-white fw-bold boost-max-stake">
																Max:<br/>
																€@match.ActiveBoost?.MaxStakePerBet
															</small>

															@if (@match.ActiveBoost?.MaxUsesPerUser == 9999)
															{
																<small class="badge text-white fw-bold boost-max-uses tw-inline-flex tw-items-center tw-px-3 tw-py-1.5 tw-rounded-full tw-text-xs tw-font-semibold" style="margin-left: -1em;">
																	@if (@match.ActiveBoost?.MaxUsesPerUser != 9999)
																	{
																		<div class="me-1">x</div>
																	}
																	@if (@match.ActiveBoost?.MaxUsesPerUser == 9999)
																	{
																		<div style="text-align: center;">No limit</div>
																	}
																	else
																	{
																		@match.ActiveBoost?.MaxUsesPerUser
																	}
																</small>
															}
															else
															{
																<small class="badge text-white fw-bold boost-max-uses tw-inline-flex tw-items-center tw-px-3 tw-py-1.5 tw-rounded-full tw-text-xs tw-font-semibold">
																	@if (@match.ActiveBoost?.MaxUsesPerUser != 9999)
																	{
																		<div class="me-1">x</div>
																	}
																	@if (@match.ActiveBoost?.MaxUsesPerUser == 9999)
																	{
																		<div style="text-align: center;">No limit</div>
																	}
																	else
																	{
																		@match.ActiveBoost?.MaxUsesPerUser
																	}
																</small>
															}


														</td>
													</tr>
												}
												</tbody>
											</table>
											
											<div class="d-flex justify-content-center mb-3 odds-container">
												<div class="tw-overflow-x-auto">

													<!-- Odds table (hidden when postponed) -->
													<table class="odds-table @(match.IsPostponed ? "d-none" : "")">
														
													</table>

													<!-- Postponed card (hidden by default) -->
													<div class="d-flex justify-content-center mb-3">
														<div class="postponed-card text-center p-4 animate__animated animate__fadeIn @(match.IsPostponed ? "" : "d-none")">

															<i class="bi bi-pause-circle-fill mb-2 postponed-icon"></i>
															<h6 class="fw-bold mb-1">Match Postponed</h6>
															<p class="text-muted mb-0">
																The new date will be announced soon.
															</p>

														</div>
													</div>

												</div>
											</div>


										</div>

										</div>
										<!-- Event content -->
										<div id="event-countdown" class="countdown text-danger fw-bold d-flex justify-content-center align-items-center"></div>
								</div>

								<!-- Hidden mask shown on match start -->
								<div class="event-mask d-none">
									<div class="mask-content text-center animate__animated animate__flipInY">
										<p>This event already started !</p>
									</div>								
								</div>
							</div>
						</div>
					</div>
				}
			</div>
		}
	</div>
</div>

<script>

	document.addEventListener('DOMContentLoaded', function() {

		const allTableHeaders = document.querySelectorAll('.odds-table th');

		allTableHeaders.forEach(header => {
			header.addEventListener('mouseover', function() {

				const parentTable = this.closest('.odds-table');
				if (!parentTable) return;

				const headersInThisTable = parentTable.querySelectorAll('th');
				const columnIndex = Array.from(headersInThisTable).indexOf(this);
				if (columnIndex === -1) return;

				this.classList.add('highlighted-column');

				const rowsInThisTable = parentTable.querySelectorAll('tbody tr');

				rowsInThisTable.forEach(row => {
					// Skip boost-timer-row
					if (row.classList.contains('boost-timer-row')) return;

					const cells = row.querySelectorAll('td');
					if (cells[columnIndex]) {
						cells[columnIndex].classList.add('highlighted-column');
					}
				});
			});

			header.addEventListener('mouseout', function() {

				const parentTable = this.closest('.odds-table');
				if (!parentTable) return;

				const headersInThisTable = parentTable.querySelectorAll('th');
				const columnIndex = Array.from(headersInThisTable).indexOf(this);
				if (columnIndex === -1) return;

				this.classList.remove('highlighted-column');

				const rowsInThisTable = parentTable.querySelectorAll('tbody tr');

				rowsInThisTable.forEach(row => {
					// Skip boost-timer-row
					if (row.classList.contains('boost-timer-row')) return;

					const cells = row.querySelectorAll('td');
					if (cells[columnIndex]) {
						cells[columnIndex].classList.remove('highlighted-column');
					}
				});
			});
		});
	});

	document.querySelectorAll('.event-card').forEach(card => {

		// Skip postponed or missing kickoff
		if (card.dataset.postponed === "true") return;
		if (!card.dataset.kickoff) return;

		const kickoffDate = new Date(card.dataset.kickoff);
		if (isNaN(kickoffDate)) return;

		const userTimeZone = card.dataset.userTz;

		const formatter = new Intl.DateTimeFormat(undefined, {
			weekday: 'short',
			year: 'numeric',
			month: 'short',
			day: 'numeric',
			hour: '2-digit',
			minute: '2-digit',
			hour12: true,
			timeZone: userTimeZone
		});

		const formattedDate = formatter.format(kickoffDate);
		const dateEl = card.querySelector('#event-date-time');
		if (dateEl) {
			dateEl.textContent = formattedDate;
		}
	});


	function updateEventClocks() {
		document.querySelectorAll('.event-card').forEach(card => {

			const isPostponed = card.dataset.postponed === "true";

			if (isPostponed) {
			
				applyPostponedState(card);
				return; // skip ALL timing logic
			}

			const kickoffStr = card.dataset.kickoff;
			const kickoffTime = new Date(kickoffStr); // UTC datetime
			const now = new Date(); // also in UTC (local browser time, but same reference)

			const timeDiffMs = kickoffTime.getTime() - now.getTime();

			const countdownEl = card.querySelector('.countdown');
			const mask = card.querySelector('.event-mask');
			const oddsTable = card.querySelector('.odds-table');

			if (timeDiffMs <= 0) {
				countdownEl.classList.add('d-none');
				countdownEl.textContent = '';
				mask.classList.remove('d-none');
				if (oddsTable) oddsTable.classList.add('d-none');
			} else if (timeDiffMs <= 60 * 60 * 1000) {
				const mins = Math.floor(timeDiffMs / 1000 / 60);
				const secs = Math.floor((timeDiffMs / 1000) % 60);
				countdownEl.classList.remove('d-none');
				countdownEl.textContent = `Starts in ${mins}m ${secs}s`;
			} else {
				countdownEl.classList.add('d-none');
				countdownEl.textContent = '';
			}
		});
	}

	updateEventClocks();
	setInterval(updateEventClocks, 1000);

	document.querySelectorAll('.mask-content').forEach(el => {
		el.addEventListener('animationend', () => {
			el.classList.add('mask-rotated');
		});
	});

	function filterMatches() {
		const searchInput = document.getElementById('matchSearch');
		const searchQuery = searchInput.value.trim().toLowerCase();
		const cards = document.querySelectorAll('.event-card');

		let anyMatch = false;
		let exactMatchCard = null;

		activateAllTab();  // Always search in "All" tab

		cards.forEach(card => {
			const home = card.querySelectorAll('[data-team-name]')[0].dataset.teamName.toLowerCase();
			const away = card.querySelectorAll('[data-team-name]')[1].dataset.teamName.toLowerCase();

			const matchesSearch = home.includes(searchQuery) || away.includes(searchQuery);


			if (searchQuery && (home === searchQuery || away === searchQuery)) {
				exactMatchCard = card;
			}

			card.closest('.col').style.display = matchesSearch ? '' : 'none';

			if (matchesSearch) anyMatch = true;
		});

		const message = document.getElementById('noMatchesMessage');
		message.classList.toggle('visible', !anyMatch);

		// If search input fields is cleared, switch to All tab again
		if (searchQuery === '') {
			activateAllTab();
		}
	}

	function getUniqueEventDates() {
		const dateSet = new Set();

		document.querySelectorAll('.event-card').forEach(card => {

			// skip postponed or missing kickoff

			if (card.dataset.postponed === "true") return;
			if (!card.dataset.kickoff) return;

			const kickoff = new Date(card.dataset.kickoff);
			if (isNaN(kickoff)) return;

			const dateStr = kickoff.toISOString().split('T')[0];
			dateSet.add(dateStr);
		});

		return Array.from(dateSet).sort();
	}

	document.getElementById('matchSearch').addEventListener('input', filterMatches);

	function renderDatePills() {

		function hasPostponedMatches() {
			return document.querySelector('.event-card[data-postponed="true"]') !== null;
		}

		const container = document.getElementById('datePillContainer');
		container.innerHTML = '';

		const allBtn = document.createElement('button');
		allBtn.textContent = 'All';
		allBtn.className = 'custom-date-pill me-2 active';
		allBtn.dataset.date = 'all';
		allBtn.id = 'allTab';  

		container.appendChild(allBtn);

		getUniqueEventDates().forEach(date => {
			const btn = document.createElement('button');
			const dateObj = new Date(date);
			const displayText = formatDisplayDate(dateObj); // Jul 24th Thu

			btn.textContent = displayText;
			btn.className = 'custom-date-pill me-2';
			btn.dataset.date = date;
			container.appendChild(btn);
		});

		if (hasPostponedMatches()) {
			const postponedBtn = document.createElement('button');
			postponedBtn.className = 'custom-date-pill me-2';
			postponedBtn.dataset.date = 'postponed';

			const icon = document.createElement('i');
			icon.className = 'bi bi-pause-circle-fill me-1';

			postponedBtn.appendChild(icon);
			postponedBtn.appendChild(document.createTextNode('Postponed'));

			container.appendChild(postponedBtn);
		}
	}

	function getOrdinalSuffix(day) {
		const j = day % 10, k = day % 100;
		if (j === 1 && k !== 11) return day + "st";
		if (j === 2 && k !== 12) return day + "nd";
		if (j === 3 && k !== 13) return day + "rd";
		return day + "th";
	}

	function formatDisplayDate(dateObj) {

		const today = new Date(); // local time for the user 
		const tomorrow = new Date();
		tomorrow.setDate(today.getDate() + 1);

		const todayStr = today.toLocaleDateString().split('T')[0];
		const tomorrowStr = tomorrow.toLocaleDateString().split('T')[0];
		const dateStr = dateObj.toLocaleDateString().split('T')[0];

		if (dateStr === todayStr) {
			return "Today";
		}
		if (dateStr === tomorrowStr) {
			return "Tomorrow";
		}

		const month = dateObj.toLocaleString(undefined, { month: 'short' }); // "Aug"
		const weekday = dateObj.toLocaleString(undefined, { weekday: 'short' }); // "Sat"
		const day = getOrdinalSuffix(dateObj.getDate()); // "30th"
		return `${month} ${day} ${weekday}`; // "Aug 30th Sat"
	}

	// Helper method for activating the all tab when searching

	function activateAllTab() {
		const allTab = document.getElementById('allTab');
		if (allTab && !allTab.classList.contains('active')) {
			allTab.click();
		}
	}

	document.addEventListener('click', function (e) {
		if (e.target.matches('#datePillContainer button')) {
			const selected = e.target.dataset.date;

			// toggle active class
			document.querySelectorAll('#datePillContainer button').forEach(btn =>
				btn.classList.remove('active'));
			e.target.classList.add('active');

			// apply filter
			document.querySelectorAll('.event-card').forEach(card => {

				const isPostponed = card.dataset.postponed === "true";
				const isBoosted = card.dataset.hasBoost === "true";
				let matches = false;

				if (selected === 'all') {
					matches = true;
				}
				else if (selected === 'boosted') {
					matches = isBoosted;
				}
				else if (selected === 'postponed') {
					matches = isPostponed;
				}
				else {
					// Date pills → NEVER include postponed
					if (isPostponed || !card.dataset.kickoff) {
						matches = false;
					} else {
						const kickoffDate = card.dataset.kickoff.split('T')[0];
						matches = kickoffDate === selected;
					}
				}

				card.closest('.col').style.display = matches ? '' : 'none';
			});
				}
	});

	document.addEventListener('DOMContentLoaded', () => {
		renderDatePills();
		syncBoostedDatePill();

	});

	document.addEventListener("DOMContentLoaded", function () {
		const connection = new signalR.HubConnectionBuilder()
			.withUrl("/matchEventHub")
			.withAutomaticReconnect()
			.build();

		connection.start()
			.then(() => {
				console.log("SignalR connected");
				document.querySelectorAll('.event-card').forEach(card => {
					const matchId = card.dataset.matchId;
					console.log("Subscribing to match", matchId);
					connection.invoke("SubscribeToEvent", matchId)
						.then(() => console.log("Subscribed to", matchId))
						.catch(err => console.error(`Failed to subscribe to match ${matchId}:`, err.toString()));
				});
		})

		connection.on("MatchEventUpdated", function (update) {

				if (update.activeBoostId === null) {

				const card = document.querySelector(`[data-match-id="${update.matchEventId}"]`);
					if (!card) return;

					// Only reset if the card WAS boosted
					if (card.dataset.hasBoost === "true") {

						const timerRow = card.querySelector(".boost-timer-row");
						if (timerRow) resetBoost(timerRow);

						["Home", "Draw", "Away"].forEach(opt => {
							localStorage.removeItem(`boost_${update.matchEventId}_${opt}`);
						});
				}

				// 🚨 DO NOT RETURN
			}


			const card = document.querySelector(`[data-match-id="${update.matchEventId}"]`);
			if (!card) return;

			const homeOddsElement = card.querySelector('tbody span[data-option="Home"]');
			const drawOddsElement = card.querySelector('tbody span[data-option="Draw"]');
			const awayOddsElement = card.querySelector('tbody span[data-option="Away"]');

			const homeHeader = card.querySelector('thead th[data-option="Home"]');
			const drawHeader = card.querySelector('thead th[data-option="Draw"]');
			const awayHeader = card.querySelector('thead th[data-option="Away"]');

			const hasBoost = update.activeBoostId != null;

			if (!hasBoost) {
				// No boost, just run original logic
					if (homeOddsElement && homeHeader) {
						homeHeader.dataset.odds = update.homeOdds;
						animateOddsChange(homeOddsElement, update.homeOdds, update.matchEventId, "Home", false);
					}

					if (drawOddsElement && drawHeader) {
						drawHeader.dataset.odds = update.drawOdds;
						animateOddsChange(drawOddsElement, update.drawOdds, update.matchEventId, "Draw", false);
					}

					if (awayOddsElement && awayHeader) {
						awayHeader.dataset.odds = update.awayOdds;
						animateOddsChange(awayOddsElement, update.awayOdds, update.matchEventId, "Away", false);
					}
			} else {

				// Boosted match logic
				// Use effective odds and ensure boost prevails in the UI and localStorage
				animateOddsChange(homeOddsElement, update.effectiveHomeOdds, update.matchEventId, "Home", true);
				animateOddsChange(drawOddsElement, update.effectiveDrawOdds, update.matchEventId, "Draw", true);
				animateOddsChange(awayOddsElement, update.effectiveAwayOdds, update.matchEventId, "Away", true);

				if (homeHeader) homeHeader.dataset.odds = update.effectiveHomeOdds.toFixed(2);
				if (drawHeader) drawHeader.dataset.odds = update.effectiveDrawOdds.toFixed(2);
				if (awayHeader) awayHeader.dataset.odds = update.effectiveAwayOdds.toFixed(2);
			}
		});

		connection.on("MatchPostponed", msg => {
			const card = document.querySelector(
				`.event-card[data-match-id="${msg.matchEventId}"]`
			);
			if (!card) return;

			applyPostponedState(card);

			renderDatePills();
			updateMatchCount();
		});


		connection.onclose(err => console.error("SignalR disconnected:", err));

		connection.onreconnected(id => console.log("SignalR reconnected with id:", id));

		connection.on("BoostStarted", (boostData) => {

			const card = document.querySelector(`[data-match-id="${boostData.matchEventId}"]`);
			if (!card) {
				console.warn("[Boost] No card for match", boostData.matchEventId);
				return;
			}

			card.dataset.hasBoost = "true";

			const oddsRow = card.querySelector("tbody tr:not(.boost-timer-row)")
						 || card.querySelector("tbody tr");
			if (!oddsRow) {
				console.warn("[Boost] No odds row found in card", boostData.matchEventId);
				return;
			}

			scheduleBoost(oddsRow, boostData);
			syncBoostedDatePill();
		});


	});

	const boostTimers = new Map();

	function animateOddsChange(element, newOdds, matchId, option, isBoosted = false) {
		if (!element) return;

		const oldOdds = parseFloat(element.dataset.lastOdds ?? element.textContent) || 0;
		newOdds = parseFloat(newOdds);

		const boostKey = `boost_${matchId}_${option}`;
		const storedBoost = parseFloat(localStorage.getItem(boostKey));

		// Determine which odds to actually use
		let displayOdds;
		if (isBoosted && !isNaN(storedBoost)) {
			displayOdds = storedBoost; // boosted odds prevail
		} else if (isBoosted && isNaN(storedBoost)) {
			displayOdds = newOdds;
			localStorage.setItem(boostKey, displayOdds); // store boost
		} else {
			displayOdds = newOdds;
			const regKey = `reg_${matchId}_${option}`;
			if (oldOdds !== newOdds) {
				localStorage.setItem(regKey, newOdds);
			} else {
				localStorage.removeItem(regKey);
			}
		}

		if (!Number.isFinite(displayOdds) || displayOdds === oldOdds) return;

		const wentUp = displayOdds > oldOdds;
		const colorClass = wentUp ? 'odds-up' : 'odds-down';
		const animClass  = 'animate__rubberBand';

		element.textContent = displayOdds.toFixed(2);
		element.dataset.lastOdds = displayOdds;

		[...element.classList].forEach(c => {
			if (c.startsWith('animate__')) element.classList.remove(c);
		}); 

		element.classList.remove('odds-up', 'odds-down');
		void element.offsetWidth; 

		element.style.setProperty('--animate-duration', '0.8s');
		element.classList.add('animate__animated', animClass, colorClass, 'animate__slower'); 
		function onEnd(e) {
			if (e.target !== element) return;
			element.classList.remove('animate__animated', animClass, 'odds-up', 'odds-down');
			element.removeEventListener('animationend', onEnd);
			element.style.removeProperty('--animate-duration');
		}
		element.addEventListener('animationend', onEnd);
	}

	document.addEventListener("DOMContentLoaded", () => {
		document.querySelectorAll(".boost-timer-row").forEach(row => {
			const countdownEl = row.querySelector(".boost-countdown");
			const endTimeStr = row.dataset.boostEnd;
			if (!endTimeStr || !countdownEl) return;

			// Normalize the boostEnd timestamp (ensure Z for UTC, trim ms properly)
			const fixedEndTimeStr = endTimeStr.replace(/\.\d+/, m => m.slice(0, 4)) + "Z";
			const endTime = new Date(fixedEndTimeStr);

			if (isNaN(endTime)) {
				countdownEl.textContent = "Invalid";
				return;
			}

			const update = () => {
				const now = new Date();
				let diff = endTime.getTime() - now.getTime();

				if (diff <= 0) {
					clearInterval(interval);
					countdownEl.textContent = "00:00";
					resetBoost(row);
					return;
				}

				const hours = Math.floor(diff / 3600000);
				diff %= 3600000;

				const minutes = Math.floor(diff / 60000);
				diff %= 60000;

				const seconds = Math.floor(diff / 1000);

				// Format: HH:MM:SS if hours > 0, otherwise MM:SS
				const timeStr = hours > 0
					? `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`
					: `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;

				countdownEl.textContent = timeStr;
			};

			update(); // run immediately
			const interval = setInterval(update, 1000);
		});
	});

	function resetBoost(row) {

		// 0. Resolve card once
		const cardEl = row.closest(".event-card");

		// 0.1 Clear boost timers safely
		if (cardEl) {
			const key = cardEl.dataset.matchId;
			const timers = boostTimers.get(key);
			if (timers) {
				if (timers.start) clearTimeout(timers.start);
				if (timers.stop) clearTimeout(timers.stop);
				boostTimers.delete(key);
			}
		}

		// 1. Find the enclosing card-body (container for background + options)
		const cardBody = row.closest(".card-body");
		if (!cardBody) return;

		// 2. Reset all .bet-option buttons
		cardBody.querySelectorAll(".bet-option").forEach(btn => {
			btn.classList.remove("boosted");
		});

		// 3. Reset ALL bet-option pills (badges)
		cardBody.querySelectorAll(".bet-trigger .badge").forEach(pill => {
			const oldOdds = pill.querySelector(".old-odds");
			if (!oldOdds) return;

			const baseOdds = oldOdds.textContent.trim();

			// Remove boosted classes
			pill.classList.remove(
				"pill-boosted-green",
				"pill-boosted-blue",
				"pill-boosted-yellow"
			);

			// Restore brand classes
			if (pill.dataset.option === "Home") pill.classList.add("pill-brand-blue");
			if (pill.dataset.option === "Draw") pill.classList.add("pill-brand-yellow");
			if (pill.dataset.option === "Away") pill.classList.add("pill-brand-green");

			// Reset dataset
			pill.dataset.hasBoost = "false";
			pill.dataset.odds = baseOdds;

			// Reset markup
			pill.textContent = baseOdds;
		});

		// 4. Reset container visuals
		cardBody.classList.remove("boosted-match-container-effects");

		if (cardBody.dataset.isDerby === "true") {
			cardBody.classList.add("derby-match-container-effects");
		}

		// 5. Reset card dataset
		if (cardEl) {
			cardEl.dataset.hasBoost = "false";
		}

		// 6. Remove boost timer row
		row.remove();

		// 7. Sync boosted date pill
		syncBoostedDatePill();
	}


	function activateBoost(row, boostData) {
		const cardBody = row.closest(".card-body");
		if (!cardBody) return;

		cardBody.classList.add("boosted-match-container-effects");
		if (cardBody.dataset.isDerby === "true") {
			cardBody.classList.remove("derby-match-container-effects");
		}

		cardBody.querySelectorAll(".bet-option").forEach(btn => btn.classList.add("boosted"));

		cardBody.querySelectorAll(".bet-trigger .badge").forEach(pill => {
			const option = pill.dataset.option;
			let boostedOdds;
			if (option === "Home") boostedOdds = boostData.effectiveHomeOdds;
			else if (option === "Draw") boostedOdds = boostData.effectiveDrawOdds;
			else if (option === "Away") boostedOdds = boostData.effectiveAwayOdds;
			if (!boostedOdds) return;

			pill.classList.remove("pill-brand-blue", "pill-brand-yellow", "pill-brand-green");

			if (option === "Home") pill.classList.add("pill-boosted-blue");
			if (option === "Draw") pill.classList.add("pill-boosted-yellow");
			if (option === "Away") pill.classList.add("pill-boosted-green");

			pill.dataset.hasBoost = "true";
			pill.dataset.odds = boostedOdds;

			let oldOddsNode = pill.querySelector(".old-odds");
			let boostedOddsNode = pill.querySelector(".boosted-odds");

			if (!oldOddsNode || !boostedOddsNode) {
				const baseOdds = pill.textContent.trim();
				pill.innerHTML = `
					<div class="d-flex flex-column align-items-center justify-content-center">
						<span class="old-odds">${baseOdds}</span>
						<span class="boosted-odds">${boostedOdds}</span>
					</div>`;
			} else {
				boostedOddsNode.textContent = boostedOdds;
			}
		});

		const tableBody = cardBody.querySelector("tbody");
		if (tableBody && !tableBody.querySelector(".boost-timer-row")) {
			const timerRow = document.createElement("tr");
			timerRow.classList.add("boost-timer-row");

			// Make sure this is proper UTC ISO string
			const boostEndIso = new Date(boostData.boostEndUtc).toISOString();
			timerRow.dataset.boostEnd = boostEndIso;

			timerRow.innerHTML = `
				<td colspan="3" class="text-center">
					<span class="badge pill-boosted tw-inline-flex tw-items-center tw-px-3 tw-py-1.5 tw-rounded-full tw-text-xs">
						<i class="ri-fire-fill boost-fire-icon me-1"></i>
						<span class="boost-countdown">00:00</span>
					</span>
					<small class="badge text-white fw-bold boost-max-stake">Max:<br/>€${boostData.maxStake}</small>
					<small class="badge text-white fw-bold boost-max-uses">x${boostData.maxUses}</small>
				</td>`;

			tableBody.appendChild(timerRow);

			const countdownEl = timerRow.querySelector(".boost-countdown");
			const endTime = new Date(timerRow.dataset.boostEnd);

			const update = () => {
				const now = new Date();
				let diff = endTime - now;

				if (diff <= 0) {
					clearInterval(interval);
					countdownEl.textContent = "00:00";
					resetBoost(timerRow);
					return;
				}

				const hours = Math.floor(diff / 3600000);
				diff %= 3600000;
				const minutes = Math.floor(diff / 60000);
				diff %= 60000;
				const seconds = Math.floor(diff / 1000);

				countdownEl.textContent = hours > 0
					? `${hours.toString().padStart(2,"0")}:${minutes.toString().padStart(2,"0")}:${seconds.toString().padStart(2,"0")}`
					: `${minutes.toString().padStart(2,"0")}:${seconds.toString().padStart(2,"0")}`;
			};

			update();
			const interval = setInterval(update, 1000);
		}
	}

	function scheduleBoost(row, boostData) {

	  const now = Date.now();
	  const start = Date.parse(boostData.startUtc);           
	  let end = boostData.endUtc ? Date.parse(boostData.endUtc) : null;
	  if (!end && boostData.durationSeconds) end = start + boostData.durationSeconds * 1000;

	  if (!Number.isFinite(start)) return;
	  if (end && end <= now) return; // already expired

	  const key = boostData.matchEventId.toString();
	  const prev = boostTimers.get(key);
	  if (prev) { clearTimeout(prev.start); clearTimeout(prev.stop); }

	  const timers = { start: null, stop: null };

	  const doStart = () => {

		const payload = {
		  ...boostData,
		  boostEndUtc: end ? new Date(end).toISOString() : undefined
		};

		activateBoost(row, payload);

		if (end) {
		  timers.stop = setTimeout(() => {
			const timerRow = row.parentElement.querySelector(".boost-timer-row");
			if (timerRow) resetBoost(timerRow);
			boostTimers.delete(key);
		  }, Math.max(0, end - Date.now()));
		}
	  };

	  if (start <= now) {

		doStart();

	  } else {

		timers.start = setTimeout(doStart, start - now); 
	  }

	  boostTimers.set(key, timers);
	}
	
	
	// Boosted date pill dynamic creation/removal


		function syncBoostedDatePill() {
		const container = document.getElementById("datePillContainer");
		if (!container) return;

		const boostBtn = container.querySelector('button[data-date="boosted"]');
		const hasBoostedCards =
			document.querySelector('.event-card[data-has-boost="true"]') !== null;

		// If NO boosted cards left - remove the pill
		if (!hasBoostedCards && boostBtn) {

			const wasActive = boostBtn.classList.contains("active");
			boostBtn.remove();

			// If user was on Boosted tab → switch back to All
			if (wasActive) {
				const allTab = document.getElementById("allTab");
				if (allTab) allTab.click();
			}
		}

		// If boosted cards exist but pill is missing → recreate it
		if (hasBoostedCards && !boostBtn) {
			const btn = document.createElement("button");
			btn.className = "custom-date-pill me-2";
			btn.dataset.date = "boosted";

			const icon = document.createElement("i");
			icon.className = "ri-fire-fill boost-fire-icon me-1";

			btn.appendChild(icon);
			btn.appendChild(document.createTextNode("Boosted"));

			// Insert after "All"
			const allTab = container.querySelector("#allTab");
			allTab?.after(btn);
		}
	}

	// Match count

		function updateMatchCount() {

		const cards = document.querySelectorAll('.event-card');
		let count = 0;

		cards.forEach(card => {
			if (card.dataset.postponed === "true") return;

			const col = card.closest('.col');
			if (!col || col.style.display === 'none') return;

			const oddsTable = card.querySelector('.odds-table');
			const mask = card.querySelector('.event-mask');

			// Must be visible AND bettable
			if (oddsTable && !oddsTable.classList.contains('d-none') &&
				mask && mask.classList.contains('d-none')) {
				count++;
			}
		});

		const el = document.getElementById('matchCount');
		if (el) {
			el.textContent = `All events: ${count}`;
		}
	}

	updateMatchCount();

	function renderPostponedCard(card) {
		if (!card) return;

		card.dataset.postponed = "true";
		card.dataset.kickoff = "";
		card.dataset.hasBoost = "false";

		applyPostponedState(card);
	}


	function applyPostponedState(card) {
		if (!card) return;

		// dataset is already set elsewhere
		const oddsTable = card.querySelector('.odds-table');
		oddsTable?.classList.add('d-none');

		const countdownEl = card.querySelector('.countdown');
		countdownEl?.classList.add('d-none');

		const mask = card.querySelector('.event-mask');
		mask?.classList.add('d-none');

		const dateEl = card.querySelector('#event-date-time');
		if (dateEl) {
			dateEl.textContent = 'TBD';
			dateEl.classList.add('to-be-determined');
		}

		card.querySelector('.live-event-card')
			?.classList.add('postponed-match');

		card.querySelector('.postponed-card')
			?.classList.remove('d-none');
	}

</script>

<style>
	.odds-up {
		color: #28a745;
		transition: color 0.4s ease;
	}

	.odds-down {
		color: #dc3545;
		transition: color 0.4s ease;
	}

</style>

				
